= 介绍

本指南简要介绍了使用Vert.x进行异步编程，主要针对熟悉主流非异步Web开发框架和库（例如Java EE，Spring）的开发人员。

== 关于本指南

我们假设读者熟悉Java编程语言及其生态系统。

我们将从一个由关系数据库和服务器端页面渲染支持的wiki Web应用程序开始;那么我们将通过几个步骤来改进应用程序，直到它成为一个具有“实时性”footnote:[请注意，在Web技术环境中广泛使用的术语“实时”不应与专用操作系统中的_硬件_或_软件_的实时相混淆。] 网站功能的现代单页面应用程序。随着时间的推移，你会学到：

1. 通过模板设计一个网页应用程序，使用服务器端的页面渲染，并使用关系数据库来保存数据。
2. 清洁隔离每个技术组件作为可重用的事件处理单元称为_(verticle)_。
3. 提取Vert.x服务，以便在同一JVM进程内或集群中的分布式节点之间无缝地相互通信的Verticle的设计。
4. 用异步操作测试代码。
5. 与暴露HTTP / JSON Web API的第三方服务集成。
6. 公开HTTP / JSON Web API。
7. 使用HTTPS保护和控制访问，Web浏览器会话的用户身份验证和第三方客户端应用程序的JWT令牌。
8. 重构一些代码，使用流行的RxJava库和Vert.x集成的响应式编程。
9. 使用AngularJS对单页面应用程序进行客户端编程。
10. 使用统一的Vert.x事件总线集成在SockJS上的实时Web编程。

注释：这个文档和代码示例的来源可以从https://github.com/vert-x3/vertx-guide-for-java-devs 获得。 我们欢迎问题报告，反馈和推送请求！

== 什么是Vert.x?

[quote, Vert.x 网站]
Eclipse Vert.x是在JVM上构建响应式应用程序的工具包。

Eclipse Vert.x (我们将在本文档的其余部分中称为Vert.x)是Eclipse Foundation的一个开源项目。Vert.x于2012年由Tim Fox发起。

Vert.x不是一个框架，而是一个工具包：核心库定义了用于编写异步网络应用程序的基本API，您可以为您的应用程序选择有用的模块（例如数据库连接，监控，认证，日志记录，服务发现，集群支持等）。 Vert.x基于 http://netty.io/[Netty项目]，这是JVM的高性能异步网络库。_如果需要_，Vert.x将允许您访问Netty内部结构，但总的来说，您可以更好地利用Vert.x提供的更高级别的API，而不会牺牲与_原始_Netty相比的性能。

Vert.x不强加任何打包或构建环境。由于Vert.x核心本身只是一个常规的Jar库，因此它可以嵌入作为一组Jars的应用程序，一个具有所有依赖关系的Jar，或者甚至可以部署在流行的组件和应用程序容器中。

因为Vert.x是为异步通信而设计的，所以它可以用比同步API（比如Java servlet或java.net套接字类）更少的线程来处理更多的并发网络连接。 Vert.x适用于大量应用程序：高容量消息/事件处理，微服务，API网关，用于移动应用程序的HTTP API等。Vert.x及其生态系统提供各种技术工具，端到端的响应式应用。

虽然听起来Vert.x只适用于要求苛刻的应用程序，但本指南还指出，Vert.x对于更传统的Web应用程序非常适用。 正如我们将看到的那样，代码仍然相对容易理解，但是如果应用程序需要面对流量的突然高峰，那么代码已经被写入了扩展的基本要素：_事件的异步处理_。

最后，值得一提的是，Vert.x是_使用多种语言的_，因为它支持各种流行的JVM语言：Java，Groovy，Scala，Kotlin，JavaScript，Ruby和Ceylon。 在Vert.x中支持语言的目标不仅仅是提供对API的访问，还要确保语言特定的API在每种目标语言中都是惯用的（例如，使用Scala的futures代替Vert.x的futures）。 使用不同的JVM语言开发Vert.x应用程序的不同技术部分是完全可能的。

== 核心Vert.x的概念

在Vert.x中有两个关键概念要学习：

1. _verticle_是什么。
2. _事件总线(event bus)_如何允许verticle通信。

=== 线程和编程模型

许多网络库和框架依赖于一个简单的线程策略：每个网络客户端在连接时被分配一个线程，并且这个线程处理客户端，直到它断开连接。 Servlet或使用java.io和java.net包编写的网络代码就是这种情况。虽然这种“同步I/O”线程模型具有保持简单易懂的优点，但是由于系统线程不便宜，所以它具有太多的并发连接的可扩展性，并且在繁重的负载下，操作系统内核在线程调度管理上花费了大量的时间。在这种情况下，我们需要转移到Vert.x提供坚实基础的_“异步I/O”_。 

Vert.x中的部署单位称为_Verticle_。 Verticle通过_事件循环_处理传入事件，其中事件可以是接收网络缓冲区，定时事件或其他Verticle发送的消息。在异步编程模型中，事件循环是非常典型的：

image::images/event-loop.png[]

每个事件应在合理的时间内处理，以便不阻塞事件循环。这意味着_线程阻塞_操作不应该在事件循环中执行，就像处理图形用户界面中的事件一样（例如，通过缓慢的网络请求来冻结Java/Swing接口）。正如我们将在本指南后面看到的，Vert.x提供了处理事件循环之外的阻塞操作的机制。在任何情况下，当事件循环处理事件的时间太长时，Vert.x会在日志中发出警告，这也可以根据应用程序的具体要求进行配置（例如，在较慢的IoT ARM板上工作时）。

每个事件循环都附加到一个线程。默认情况下，Vert.x会在每个CPU核心线程上添加2个事件循环。直接的结果是，一个常规的verticle总是在同一个线程上处理事件，所以不需要使用线程协调机制来操纵一个verticle状态（例如，Java类字段）。

Verticle可以通过一些配置（例如，凭证，网络地址等），并且可以被部署多次：

image::images/verticle-threading-config.png[]

传入的网络数据正在从接受线程接收，然后作为事件传递给相应的Verticle。 当一个Verticle打开一个网络服务器并且被多次部署时，那么事件将以循环的方式被分配给Verticle实例，这对于最大限度地利用CPU处理大量并发请求是非常有用的。 最后，Verticle具有简单的启动/停止生命周期，并且Verticle可以部署其他Verticle。

=== 事件总线

在Vert.x中，Verticle组成代码部署的技术单元。 Vert.x_事件总线_是不同Verticle通过异步消息传递进行通信的主要工具。 例如，假设我们有一个用于处理HTTP请求的Verticle和一个用于管理对数据库的访问的Verticle。 事件总线允许HTTP的Verticle向数据库的Verticle发送一个执行SQL查询请求，并且响应给HTTP的Verticle：

image::images/event-bus.png[]

事件总线允许传递任何类型的数据，虽然JSON是首选的交换格式，因为它允许使用不同语言编写的verticle进行通信，更为普遍是，JSON是一个流行的通用半结构化数据编组文本格式。

消息可以发送到自由形式的字符串的_目的地_。事件总线支持以下通信模式：

1. 点对点消息传递
2. 请求-响应消息传递
3. 发布/订阅广播消息

事件总线不仅允许Verticle在相同的JVM进程中进行透明通信：

* 当网络集群被激活时，事件总线被分配，以便消息可以被发送到在其他应用节点上运行的verticle，
* 事件总线可以通过简单的TCP协议访问，供第三方应用程序通信，
* 事件总线也可以暴露在通用消息传递桥(例如AMQP，Stomp)上,
* 一个SockJS桥允许Web应用程序通过在浏览器中运行的JavaScript无缝地与事件总线进行通信，接收和发布消息就像任何一个Verticle所做的一样。
