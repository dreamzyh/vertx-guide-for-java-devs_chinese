= 介绍

本指南简要介绍了使用Vert.x进行异步编程，主要针对熟悉主流非异步Web开发框架和库（例如Java EE，Spring）的开发人员。

== 关于本指南

我们假设读者熟悉Java编程语言及其生态系统。

我们将从一个由关系数据库和服务器端页面渲染支持的wiki Web应用程序开始;那么我们将通过几个步骤来改进应用程序，直到它成为一个具有“实时性”footnote:[Note that the widespread usage of the term "real-time" in the context of web technologies shall not be confused with _hard_ or _soft_ real-time in specialized operating systems.] 网站功能的现代单页面应用程序。随着时间的推移，你会学到：

1. 通过模板设计一个网页应用程序，使用服务器端的页面渲染，并使用关系数据库来保存数据。
2. 清洁隔离每个技术组件作为可重用的事件处理单元称为_(verticle)_。
3. 提取Vert.x服务，以便在同一JVM进程内或集群中的分布式节点之间无缝地相互通信的Verticle的设计。
4. 用异步操作测试代码。
5. 与暴露HTTP / JSON Web API的第三方服务集成。
6. 公开HTTP / JSON Web API。
7. 使用HTTPS保护和控制访问，Web浏览器会话的用户身份验证和第三方客户端应用程序的JWT令牌。
8. 重构一些代码，使用流行的RxJava库和Vert.x集成的响应式编程。
9. 使用AngularJS对单页面应用程序进行客户端编程。
10. 使用统一的Vert.x事件总线集成在SockJS上的实时Web编程。

注释：这个文档和代码示例的来源可以从https://github.com/vert-x3/vertx-guide-for-java-devs获得。 我们欢迎问题报告，反馈和推送请求！

== 什么是Vert.x?

[quote, Vert.x 网站]
Eclipse Vert.x是在JVM上构建响应式应用程序的工具包。

Eclipse Vert.x (我们将在本文档的其余部分中称为Vert.x)是Eclipse Foundation的一个开源项目。Vert.x于2012年由Tim Fox发起。

Vert.x不是一个框架，而是一个工具包：核心库定义了用于编写异步网络应用程序的基本API，您可以为您的应用程序选择有用的模块（例如数据库连接，监控，认证，日志记录，服务发现，集群支持等）。 Vert.x基于 http://netty.io/[Netty项目]，这是JVM的高性能异步网络库。_如果需要_，Vert.x将允许您访问Netty内部结构，但总的来说，您可以更好地利用Vert.x提供的更高级别的API，而不会牺牲与_原始_Netty相比的性能。

Vert.x不强加任何打包或构建环境。由于Vert.x核心本身只是一个常规的Jar库，因此它可以嵌入作为一组Jars的应用程序，一个具有所有依赖关系的Jar，或者甚至可以部署在流行的组件和应用程序容器中。

因为Vert.x是为异步通信而设计的，所以它可以用比同步API（比如Java servlet或java.net套接字类）更少的线程来处理更多的并发网络连接。 Vert.x适用于大量应用程序：高容量消息/事件处理，微服务，API网关，用于移动应用程序的HTTP API等。Vert.x及其生态系统提供各种技术工具，端到端的响应式应用。

虽然听起来Vert.x只适用于要求苛刻的应用程序，但本指南还指出，Vert.x对于更传统的Web应用程序非常适用。 正如我们将看到的那样，代码仍然相对容易理解，但是如果应用程序需要面对流量的突然高峰，那么代码已经被写入了扩展的基本要素：_事件的异步处理_。

最后，值得一提的是，Vert.x是_使用多种语言的_，因为它支持各种流行的JVM语言：Java，Groovy，Scala，Kotlin，JavaScript，Ruby和Ceylon。 在Vert.x中支持语言的目标不仅仅是提供对API的访问，还要确保语言特定的API在每种目标语言中都是惯用的（例如，使用Scala的futures代替Vert.x的futures）。 使用不同的JVM语言开发Vert.x应用程序的不同技术部分是完全可能的。

== 核心Vert.x的概念

在Vert.x中有两个关键概念要学习：

1. _verticle_是什么。what a _verticle_ is, and
2. _事件总线(event bus)_如何允许verticle通信。

=== 线程和编程模型

许多网络库和框架依赖于一个简单的线程策略：每个网络客户端在连接时被分配一个线程，并且这个线程处理客户端，直到它断开连接。 Servlet或使用java.io和java.net包编写的网络代码就是这种情况。虽然这种“同步I/O”线程模型具有保持简单易懂的优点，但是由于系统线程不便宜，所以它具有太多的并发连接的可扩展性，并且在繁重的负载下，操作系统内核在线程调度管理上花费了大量的时间。在这种情况下，我们需要转移到Vert.x提供坚实基础的_“异步I/O”_。 

Vert.x中的部署单位称为_Verticle_。 Verticle通过_事件循环_处理传入事件，其中事件可以是接收网络缓冲区，定时事件或其他Verticle发送的消息。在异步编程模型中，事件循环是非常典型的：

image::images/event-loop.png[]

Each event shall be processed in a _reasonable_ amount of time to not block the event loop.
This means that _thread blocking_ operations shall not be performed while executed on the event loop, exactly like processing events in a graphical user interface (e.g., freezing a Java / Swing interface by doing a slow network request).
As we will see later in this guide, Vert.x offers mechanisms to deal with blocking operations outside of the event loop.
In any case Vert.x emits warnings in logs when the event loop has been processing an event for _too long_, which is also configurable to match application-specific requirements (e.g., when working on slower IoT ARM boards).

Every event loop is attached to a thread.
By default Vert.x attaches 2 event loops per CPU core thread.
The direct consequence is that a regular verticle always processes events on the same thread, so there is no need to use thread coordination mechanisms to manipulate a verticle state (e.g, Java class fields).

A verticle can be passed some configuration (e.g., credentials, network addresses, etc) and a verticle can be deployed several times:

image::images/verticle-threading-config.png[]

Incoming network data are being received from accepting threads then passed as events to the corresponding verticles.
When a verticle opens a network server and is deployed more than once, then the events are being distributed to the verticle instances in a round-robin fashion which is very useful for maximizing CPU usage with lots of concurrent networked requests.
Finally, verticles have a simple start / stop life-cycle, and verticles can deploy other verticles.

=== Event bus 

Verticles form technical units of deployments of code in Vert.x.
The Vert.x _event bus_ is the main tool for different verticles to communicate through asynchronous message passing.
For instance suppose that we have a verticle for dealing with HTTP requests, and a verticle for managing access to the database.
The event bus allows the HTTP verticle to send a request to the database verticle that performs a SQL query, and responds back to the HTTP verticle:

image::images/event-bus.png[]

The event-bus allows passing any kind of data, although JSON is the preferred exchange format since it allows verticles written in different languages to communicate, and more generally JSON is a popular general-purpose semi-structured data marshaling text format.

Message can be sent to _destinations_ which are free-form strings.
The event bus supports the following communication patterns:

1. point-to-point messaging, and
2. request-response messaging and
3. publish / subscribe for broadcasting messages.

The event bus allows verticles to transparently communicate not just within the same JVM process:

* when network clustering is activated, the event bus is _distributed_ so that messages can be sent to verticles running on other application nodes,
* the event-bus can be accessed through a simple TCP protocol for third-party applications to communicate,
* the event-bus can also be exposed over general-purpose messaging bridges (e.g, AMQP, Stomp),
* a SockJS bridge allows web applications to seamlessly communicate over the event bus from JavaScript running in the browser by receiving and publishing messages just like any verticle would do.
