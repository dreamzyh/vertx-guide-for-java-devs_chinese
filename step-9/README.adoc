= 使用AngularJS的客户端Web应用程序

TIP: 相应的源代码位于指南存储库的 `step-9` 文件夹中。

到目前为止，我们的Web界面使用传统的HTML内容服务器端呈现。 某些类型的应用程序可以利用客户端呈现来避免整页重新加载以及接近本机应用程序的体验，从而改善用户体验。

为此目的存在许多流行的框架。 我们为本指南选择了流行的 http://angularjs.org/[AngularJS framework] 框架，但可以同时选择 https://facebook.github.io/react/[React], https://vuejs.org/[Vue.js], http://riotjs.com/[Riot] 或其他框架/库，而不会失去普遍性。

== 单页面应用程序

我们正在构建的wiki编辑应用程序允许选择一个页面，并将其前半部分作为HTML预览进行编辑，另一半是Markdown编辑器：

image::images/edit-page.png[]

HTML预览是通过在后端调用一个新端点来呈现的。在Markdown编辑器文本更改时触发渲染。 为了避免在用户忙于输入Markdown时用不必要的请求重载后端，引入了一个延迟，以便只在该延迟期间没有改变时才触发渲染。

应用程序界面也是动态的，因为新页面使删除按钮消失：

image::images/new-page.png[]

== Vert.x后端

=== 简化HTTP verticle代码

客户端应用程序需要一个后台来发布：

1. 静态HTML，CSS和JavaScript内容引导Web浏览器中的应用程序，
2. 一个Web API，通常是一个HTTP/JSON服务。

我们简化了HTTP Verticle实现，以涵盖所需的内容。 从 _步骤#8_ 的RxJava版本开始，我们移除了所有服务器端渲染代码以及身份验证和JWT令牌发布代码，来发布一个纯开放的HTTP/JSON接口。

当然，构建一个利用JWT令牌和身份验证的版本对于真实世界的部署很有意义，但现在我们已经介绍了这些功能，我们更愿意将注意力集中在本部分指南的重要部分。

作为一个例子， `apiUpdatePage` 方法实现代码如下：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=apiUpdatePage]
----

=== 发布的路由

HTTP/JSON API通过与前面步骤相同的路由进行发布：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=routes]
----

前端应用程序静态资源是从 `/app` 提供的，我们将请求重定向到  `/app/index.html` 静态文件：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=static-assets]
----
<1> 禁用缓存在开发中很有用。
<2> 默认情况下，这些文件应该位于  _classpath_ 的 `webroot` 包中，所以这些文件应该放在 `src/main/resources/webroot` 下的Maven或Gradle项目中。

最后但并非最不重要的一点，我们预计应用程序需要后端将Markdown呈现为HTML，因此我们为此提供HTTP POST端点：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=preview-rendering]
----

== AngularJS前端

TIP: 本指南不是AngularJS的完整介绍(https://docs.angularjs.org/tutorial[请参阅官方教程])，我们假设读者对框架有一定的了解。This guide is not a proper introduction to AngularJS (https://docs.angularjs.org/tutorial[see the official tutorial instead]), we assume some familiarity with the framework from the reader.

=== 应用程序视图

该界面适合单个HTML文件，其位于 `src/main/resources/webroot/index.html`.头部是：

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=head]
----
<1> AngularJS模块被命名为 `wikiApp` 。
<2> `wiki.js` 拥有AngularJS模块和控制器的代码。

正如您在AngularJS之外可以看到的，我们正在使用来自外部CDN的以下依赖项：

* https://getbootstrap.com/[Boostrap] 来设计我们的界面，
* http://fontawesome.io/[Font Awesome] 提供图标，
* https://lodash.com/[Lodash] 在JavaScript代码中提供一些有用的用语。

由于性能原因，Bootstrap需要一些可以在文档末尾加载的脚本：

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=bottom]
----

我们的AngularJS控制器被称为 `WikiController` ，它被绑定到一个也是Bootstrap容器的 `div` ：

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=container]
----

界面顶部的按钮由以下元素组成：

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=buttons-row]
----
<1> 对于每个wiki页面名称，我们使用 `ng-repeat` 和 `ng-click` 来生成一个元素，以在被点击时定义控制器操作(`加载`)。
<2> 刷新按钮绑定到 `重新加载` 控制器操作。所有其他按钮的工作方式相同。
<3> `ng-show` 指令允许我们根据控制器的 `pageExists` 方法值显示或隐藏元素。
<4> `div` 用于显示成功或失败的通知。

Markdown预览和编辑器元素如下：

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=markdown]
----
<1> `ng-model` 将 `textarea` 内容绑定到控制器的 `pageMarkdown` 属性上。

=== Application controller

The `wiki.js` JavaScript starts with an AngularJS module declaration:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=module-decl]
----

The `wikiApp` module has no plugin dependency, and declares a single `WikiController` controller.
The controller requires dependency injection of the following objects:

* `$scope` to provide DOM scoping to the controller, and
* `$http` to perform asynchronous HTTP requests to the backend, and
* `$timeout` to trigger actions after a given delay while staying tied to the AngularJS life-cycle (e.g., to ensure that any state modification triggers view changes, which is not the case when using the https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout[classic setTimeout function]).

Controller methods are being tied to the `$scope` object.
Let us start with 3 simple methods:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=new-reload-exists]
----

Creating a new page consists in initializing controller properties that are attached to the `$scope` object.
Reloading the pages objects from the backend is a matter of performing a HTTP GET request (note that the `$http` request methods return promises).
The `pageExists` method is being used to show / hide elements in the interface.

Loading the content of the page is also a matter of performing a HTTP GET request, and updating the preview a DOM manipulation:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=load]
----

The next methods support saving / updating and deleting pages.
For these operations we used the full `then` promise method with the first argument being called on success, and the second one being called on error.
We also introduce the `success` and `error` helper methods to display notifications (3 seconds on success, 5 seconds on error):

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=save-delete-notifications]
----

initializing the application state and views is done by fetching the pages list, and starting with a blank new page editor:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=init]
----

Finally here is how we perform live rendering of Markdown text:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=live-rendering]
----
<1> `$scope.$watch` allows being notified of state changes. Here we monitor changes on the `pageMarkdown` property that is bound to the editor `textarea`.
<2> 300 milliseconds is a _fine_ delay to trigger rendering if nothing has changed in the editor.
<3> Timeouts are promise, so if the state has changed we cancel the previous one and create a new one. This is how we delay rendering instead of doing it on every keystroke.
<4> We ask the backend to render the editor text into some HTML, then refresh the preview.

