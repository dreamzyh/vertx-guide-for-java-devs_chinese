= 使用AngularJS的客户端Web应用程序

TIP: 相应的源代码位于指南存储库的 `step-9` 文件夹中。

到目前为止，我们的Web界面使用传统的HTML内容服务器端呈现。 某些类型的应用程序可以利用客户端呈现来避免整页重新加载以及接近本机应用程序的体验，从而改善用户体验。

为此目的存在许多流行的框架。 我们为本指南选择了流行的 http://angularjs.org/[AngularJS framework] 框架，但可以同时选择 https://facebook.github.io/react/[React], https://vuejs.org/[Vue.js], http://riotjs.com/[Riot] 或其他框架/库，而不会失去普遍性。

== 单页面应用程序

我们正在构建的wiki编辑应用程序允许选择一个页面，并将其前半部分作为HTML预览进行编辑，另一半是Markdown编辑器：

image::images/edit-page.png[]

HTML预览是通过在后端调用一个新端点来呈现的。在Markdown编辑器文本更改时触发渲染。 为了避免在用户忙于输入Markdown时用不必要的请求重载后端，引入了一个延迟，以便只在该延迟期间没有改变时才触发渲染。

应用程序界面也是动态的，因为新页面使删除按钮消失：

image::images/new-page.png[]

== Vert.x后端

=== 简化HTTP verticle代码

客户端应用程序需要一个后台来发布：

1. 静态HTML，CSS和JavaScript内容引导Web浏览器中的应用程序，
2. 一个Web API，通常是一个HTTP/JSON服务。

我们简化了HTTP Verticle实现，以涵盖所需的内容。 从 _步骤#8_ 的RxJava版本开始，我们移除了所有服务器端渲染代码以及身份验证和JWT令牌发布代码，来发布一个纯开放的HTTP/JSON接口。

当然，构建一个利用JWT令牌和身份验证的版本对于真实世界的部署很有意义，但现在我们已经介绍了这些功能，我们更愿意将注意力集中在本部分指南的重要部分。

作为一个例子， `apiUpdatePage` 方法实现代码如下：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=apiUpdatePage]
----

=== 发布的路由

HTTP/JSON API通过与前面步骤相同的路由进行发布：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=routes]
----

前端应用程序静态资源是从 `/app` 提供的，我们将请求重定向到  `/app/index.html` 静态文件：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=static-assets]
----
<1> 禁用缓存在开发中很有用。
<2> 默认情况下，这些文件应该位于  _classpath_ 的 `webroot` 包中，所以这些文件应该放在 `src/main/resources/webroot` 下的Maven或Gradle项目中。

最后但并非最不重要的一点，我们预计应用程序需要后端将Markdown呈现为HTML，因此我们为此提供HTTP POST端点：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=preview-rendering]
----

== AngularJS frontend

TIP: This guide is not a proper introduction to AngularJS (https://docs.angularjs.org/tutorial[see the official tutorial instead]), we assume some familiarity with the framework from the reader.

=== Application view

The interface fits in a single HTML file located at `src/main/resources/webroot/index.html`.
The `head` section is:

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=head]
----
<1> The AngularJS module is named `wikiApp`.
<2> `wiki.js` holds the code for our AngularJS module and controller.

As you can see beyond AngularJS we are using the following dependencies from external CDNs:

* https://getbootstrap.com/[Boostrap] to style our interface,
* http://fontawesome.io/[Font Awesome] to provide icons,
* https://lodash.com/[Lodash] to help with some functional idioms in our JavaScript code.

Bootstrap requires some further scripts that can be loaded at the end of the document for performance reasons:

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=bottom]
----

Our AngularJS controller is called `WikiController` and it is bound to a `div` which is also a Bootstrap container:

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=container]
----

The buttons on top of the interface consist of the following elements:

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=buttons-row]
----
<1> For each wiki page name we generate an element using `ng-repeat` and `ng-click` to define the controller action (`load`) when it is being clicked.
<2> The refresh button is bound to the `reload` controller action. All other buttons work the same way.
<3> The `ng-show` directive allows us to show or hide the element depending on the controller `pageExists` method value.
<4> This `div` is used to display notifications of success or failures.

The Markdown preview and editor elements are the following:

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=markdown]
----
<1> `ng-model` binds the `textarea` content to the `pageMarkdown` property of the controller.

=== Application controller

The `wiki.js` JavaScript starts with an AngularJS module declaration:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=module-decl]
----

The `wikiApp` module has no plugin dependency, and declares a single `WikiController` controller.
The controller requires dependency injection of the following objects:

* `$scope` to provide DOM scoping to the controller, and
* `$http` to perform asynchronous HTTP requests to the backend, and
* `$timeout` to trigger actions after a given delay while staying tied to the AngularJS life-cycle (e.g., to ensure that any state modification triggers view changes, which is not the case when using the https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout[classic setTimeout function]).

Controller methods are being tied to the `$scope` object.
Let us start with 3 simple methods:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=new-reload-exists]
----

Creating a new page consists in initializing controller properties that are attached to the `$scope` object.
Reloading the pages objects from the backend is a matter of performing a HTTP GET request (note that the `$http` request methods return promises).
The `pageExists` method is being used to show / hide elements in the interface.

Loading the content of the page is also a matter of performing a HTTP GET request, and updating the preview a DOM manipulation:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=load]
----

The next methods support saving / updating and deleting pages.
For these operations we used the full `then` promise method with the first argument being called on success, and the second one being called on error.
We also introduce the `success` and `error` helper methods to display notifications (3 seconds on success, 5 seconds on error):

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=save-delete-notifications]
----

initializing the application state and views is done by fetching the pages list, and starting with a blank new page editor:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=init]
----

Finally here is how we perform live rendering of Markdown text:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=live-rendering]
----
<1> `$scope.$watch` allows being notified of state changes. Here we monitor changes on the `pageMarkdown` property that is bound to the editor `textarea`.
<2> 300 milliseconds is a _fine_ delay to trigger rendering if nothing has changed in the editor.
<3> Timeouts are promise, so if the state has changed we cancel the previous one and create a new one. This is how we delay rendering instead of doing it on every keystroke.
<4> We ask the backend to render the editor text into some HTML, then refresh the preview.

