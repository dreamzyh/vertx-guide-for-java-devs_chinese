= 重构成独立和可重用的Verticle

TIP: 相应的源代码位于指南存储库的step-2文件夹中。

第一次迭代给了我们一个工作的wiki应用程序。 尽管如此，它的实现仍然存在以下问题：

1. HTTP请求处理和数据库访问代码在相同的方法中交错
2. 许多配置数据（例如，端口号，JDBC驱动程序等）都是代码中的硬编码字符串。

== 架构和技术选择

第二个迭代是将代码重构为独立的可重用的Verticle：

image::images/verticles-refactoring.png[Verticles refactoring]

我们将部署2个Verticle来处理HTTP请求，1个Verticle通过数据库来封装持久化。 由此产生的两个Verticle将不会彼此直接引用，因为它们只会在事件总线的目标名称以及消息格式进行交流。 这提供了一个简单而有效的解耦。

事件总线上发送的消息将以JSON编码。 虽然Vert.x在事件总线上支持灵活的序列化方案以处理要求严格的或高度特定的上下文，但使用JSON数据通常是明智的选择。 使用JSON的另一个优点是它是一种与语言无关的文本格式。 由于Vert.x是 _支持多种开发语言_，JSON是一个理想选择，用于不同语言编写的verticle需要通过消息传递进行通信。The messages sent on the event bus will be encoded in JSON.
While Vert.x supports flexible serialization schemes on the event bus for demanding or highly-specific contexts, it is generally a wise choice to go with JSON data.
Another advantage of using JSON is that it is a language-agnostic text format.
As Vert.x is _polyglot_, JSON is ideal shall verticles written in different languages need to communicate via message passing.

== HTTP服务器verticle

Verticle类的前言和 `start` 方法如下所示：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/HttpServerVerticle.java[tags=start]
----
<1> 我们公开了verticle配置参数的公共常量：HTTP端口号和事件总线目的地的名称，以将消息发布到数据库verticle。
<2> `AbstractVerticle#config()` 方法允许访问已经提供的verticle配置。 如果没有给定具体的值,第二个参数是默认值。
<3> 配置值只是字符串对象，也可以是整数，布尔值，复杂的JSON数据等。

这个类的其余部分主要是纯HTTP代码的提取，之前的数据库代码被事件总线消息替代。 这里是 `indexHandler` 方法代码：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/HttpServerVerticle.java[tags=indexHandler]
----
<1> `vertx` 对象可以访问事件总线，并且我们发送一条消息给数据库vertice的队列。
<2> 传递选项允许我们指定标头，有效负载编解码器和超时。
<3> 答复成功后，将包含一个有效载荷。

正如我们所看到的，一个事件总线消息由一个主体，选项组成，并且可以选择期待一个回复。 如果没有预期的响应，则 `send` 方法的变量没有对应的处理程序。

我们将有效载荷编码为JSON对象，并通过称为 `action` 的消息头指定数据库Verticle应执行的操作。

其余的Verticle代码包含路由器处理程序，它们也使用事件总线来获取和存储数据：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/HttpServerVerticle.java[tags=rest]
----

== 数据库verticle

使用JDBC连接到数据库当然需要一个驱动程序和配置，这是我们在第一次迭代中硬编码的。

=== 可配置的SQL查询

虽然Verticle会将之前硬编码的值转换为配置参数，但是我们还将通过从属性文件中加载SQL查询来更进一步操作。

查询将从作为配置参数传递的文件或从默认资源（如果没有提供文件）中加载。 这种方法的优点是Verticle可以适应不同的JDBC驱动程序和SQL方言。

verticle类的前言主要由配置密钥定义组成：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/WikiDatabaseVerticle.java[tags=preamble]
----

SQL queries are being stored in a properties file, with the default ones for HSQLDB being located in `src/main/resources/db-queries.properties`:

----
include::src/main/resources/db-queries.properties[tags=queries]
----

The following code from the `WikiDatabaseVerticle` class loads the SQL queries from a file, and make them available from a map:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/WikiDatabaseVerticle.java[tags=loadSqlQueries]
----

We use the `SqlQuery` enumeration type to avoid string constants later in the code.
The code of the verticle `start` method is the following:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/WikiDatabaseVerticle.java[tags=start]
----
<1> Interestingly we break an important principle in Vert.x which is to avoid blocking APIs, but since there are no asynchronous APIs for accessing resources on the classpath our options are limited. We could use the Vert.x `executeBlocking` method to offload the blocking I/O operations from the event loop to a worker thread, but since the data is very small there is no obvious benefit in doing so.
<2> Here is an example of using SQL queries.
<3> The `consumer` method registers an event bus destination handler.

=== Dispatching requests

The event bus message handler is the `onMessage` method:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/WikiDatabaseVerticle.java[tags=onMessage]
----

We defined a `ErrorCodes` enumeration for errors, which we use to report back to the message sender.
To do so, the `fail` method of the `Message` class provides a convenient shortcut to reply with an error, and the original message sender gets a failed `AsyncResult`.

=== Reducing the JDBC client boilerplate

So far we have seen the _complete_ interaction to perform a SQL query:

1. retrieve a connection,
2. perform requests,
3. release the connection.

This leads to code where lots of error processing needs to happen for each asynchronous operation, as in:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/WikiDatabaseVerticle.java[tags=query-with-connection]
----

Starting from Vert.x 3.5.0, the JDBC client now supports _one-shot_ operations where a connection is being acquired to do a SQL operation, then released internally.
The same code as above now reduces to:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/WikiDatabaseVerticle.java[tags=query-simple-oneshot]
----

This is very useful for cases where the connection is being acquired for a single operation.
Performance-wise it is important to note that re-using a connection for chained SQL operations is better.

The rest of the class consists of private methods called when `onMessage` dispatches incoming messages:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/WikiDatabaseVerticle.java[tags=rest]
----

== Deploying the verticles from a main verticle

We still have a `MainVerticle` class, but instead of containing all the business logic like in the initial iteration, its sole purpose is to bootstrap the application and deploy other verticles.

The code consists in deploying 1 instance of `WikiDatabaseVerticle` and 2 instances of `HttpServerVerticle` :

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=main]
----
<1> Deploying a verticle is an asynchronous operation, so we need a `Future` for that. The `String` parametric type is because a verticle gets an identifier when successfully deployed.
<2> One option is to create a verticle instance with `new`, and pass the object reference to the `deploy` method. The `completer` return value is a handler that simply completes its future.
<3> Sequential composition with `compose` allows to run one asynchronous operation after the other. When the initial future completes successfully, the composition function is invoked.
<4> A class name as a string is also an option to specify a verticle to deploy. For other JVM languages string-based conventions allow a module / script to be specified.
<5> The `DeploymentOption` class allows to specify a number of parameters and especially the number of instances to deploy.
<6> The composition function returns the next future. Its completion will trigger the completion of the composite operation.
<7> We define a handler that eventually completes the `MainVerticle` start future.

The astute reader will probably wonder how we can deploy the code for a HTTP server on the same TCP port twice and not expect any error for either of the instances, since the TCP port will already be in use.
With many web frameworks we would need to choose different TCP ports, and have a frontal HTTP proxy to perform load balancing between the ports.

There is no need to do that with Vert.x as multiple verticles can share the same TCP ports.
Incoming connections are simply distributed in a round-robin fashion from accepting threads.
