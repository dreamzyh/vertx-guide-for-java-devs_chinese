= 使用RxJava进行响应式编程

TIP: 相应的源代码位于指南存储库的 `step-8` 文件夹中。

到目前为止，我们已经使用基于回调的API探索了Vert.x堆栈的各个领域。 它只是能运行，并且这种编程模型在很多编程语言的开发人员中都是众所周知的。 然而，它可能会变得有点乏味，特别是当你结合几个事件源或处理复杂的数据流时。

这正是RxJava发挥的作用，Vert.x可以无缝集成它。

== 启用RxJava API

除了基于回调的API之外，Vert.x模块还提供了 _"Rxified"_ API。 要启用它，首先将 `vertx-rx-java` 模块添加到Maven POM文件中：

[source,xml,indent=0]
----
include::pom.xml[tags=vertx-rx-java]
----

Verticle必须进行修改，以便扩展 `io.vertx.rxjava.core.AbstractVerticle` 而不是  `io.vertx.core.AbstractVerticle` 。 这有什么不同？ 前一类扩展了后者，并发布了一个 `io.vertx.rxjava.core.Vertx` 字段。

`io.vertx.rxjava.core.Vertx` 定义了额外的 `rxSomething(...)` 方法，这些方法等同于基于回调的对应方法。

让我们来看看  `MainVerticle`  以更好地了解它在实践中的工作原理：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=rx-deploy-verticle]
----

`rxDeploy` 方法不会将 `Handler<AsyncResult<String>>` 作为最终参数。 相反，它返回一个 `Single<String>` 。

此外，调用该方法时操作不会启动。 它在您订阅 `Single` 时开始。 操作完成后，它会发出部署 `id` 或用 `Throwable` 指示问题的原因。

== 按顺序部署Verticle

为了完成 `MainVerticle` 重构，我们必须确保部署操作被触发并按顺序发生：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=rx-sequential-composition]
----
<1> `flatMap` 运算符将该函数应用于 `dbVerticleDeployment` 的结果。 它在这里安排 `HttpServerVerticle` 的部署。
<2> 订阅时开始操作。 在成功或出错时，`MainVerticle` 开始 future 将完成或失败。

== 部分 _"Rxifying"_ `HttpServerVerticle`

如果按顺序跟随指南，随时编辑代码，则您的 `HttpServerVerticle` 类仍在使用基于回调的API。 在您可以使用RxJava API _自然地_ （即同时）执行异步操作之前，您需要重构 `HttpServerVerticle` 。

=== 导入Vert.x类的RxJava版本

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=rx-imports]
----
<1> 我们的 `backupHandler()` 方法仍然使用 `HttpResponse` 类，所以它必须被导入。 事实证明，由Vert.x提供的 `HttpResponse` 的RxJava版本可以作为这种特定情况下的直接替换。 指南存储库的 `step-8` 文件夹中的 _"Rxified"_ 代码不会导入此类，因为响应类型是由lambda表达式推断的。

=== 在 _"Rxified"_ `vertx` 实例上使用委托

要调用需要 `io.vertx.core.Vertx` 实例的方法(如果有 `io.vertx.rxjava.core.Vertx` 实例)，请调用getDelegate()方法。 在创建 `WikiDatabaseService` 的实例时需要调整Verticle的 `start()` 方法：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=rx-vertx-delegate]
----

== Executing authorization queries concurrently

In the previous example, we saw how to use RxJava operators and the Rxified Vert.x API to execute asynchronous operations in order.
But sometimes this guarantee is not required, or you simply want them to run concurrently for performance reasons.

The JWT token generation process in the `HttpServerVerticle` is a good example of such a situation.
To create a token, we need all authorization query results to complete, but queries are independent from each other:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=rx-concurrent-composition]
----
<1> Three `Single` objects are created, representing the different authorization queries.
<2> When the three operations complete successfully, the `zip` operator callback is invoked with the results.

== Working with database connections

To acquire a database connection from the pool, all you have to do is calling `rxGetConnection` on the `JDBCClient`:

[source,java,indent=0]
----
Single<SQLConnection> connection = dbClient.rxGetConnection();
----

The method returns a `Single<Connection>` which you can easily transform with `flatMap` to execute SQL queries:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/database/WikiDatabaseServiceImpl.java[tags=rx-execute-query-with-params]
----

But how can we release the connection if the `SQLConnection` reference is no longer reachable?
A simple and convenient way to do this is to invoke `close` when the `Single<SQLConnection>` is unsubscribed:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/database/WikiDatabaseServiceImpl.java[tags=rx-get-connection]
----
<1> After the connection is acquired we wrap it into a `Single`
<2> The `Single` is modified to invoke `close` when unsubscribed

Now we shall use `getConnection` anytime we need to execute SQL queries in our database verticle.

== Bridging the gap between callbacks and RxJava

At times, you may have to mix your RxJava code with a callback-based API.
For example, service proxy interfaces can only be defined with callbacks, but the implementation uses the Vert.x Rxified API.

In this case, the `io.vertx.rx.java.RxHelper` class can adapt a `Handler<AsyncResult<T>>` to an RxJava `Subscriber<T>`:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/database/WikiDatabaseServiceImpl.java[tags=rxhelper-to-subscriber]
----
<1> `fetchAllPagesData` is an asynchronous service proxy operation, defined with a `Handler<AsyncResult<List<JsonObject>>>` callback.
<2> The `toSubscriber` method adapts the `resultHandler` to a `Subscriber<List<JsonObject>>`, so that the handler is invoked when the list of rows is emitted.

== Data flows

RxJava is not only great at combining different sources of events, it is also very helpful with data flows.
Unlike a Vert.x or JDK future, an `Observable` emits a stream of events, not just a single one.
And it comes with an extensive set of data manipulation operators.

We can use a few of them to refactor the `fetchAllPages` database verticle method:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/database/WikiDatabaseServiceImpl.java[tags=rx-data-flow]
----
<1> With `flatMapObservable` we will create an `Observable` from the item emitted by the `Single<Result>`.
<2> `from` converts the database `results` iterable into an `Observable` emitting the database row items.
<3> Since we only need the page name we can `map` each `JsonObject` row to the first column.
<4> The client expects the data to be `sorted` in alphabetical order.
<5> The event bus service reply consists in a single `JsonArray`. `collect` creates a new one with `JsonArray::new` and later adds items as they are emitted with `JsonArray::add`.
