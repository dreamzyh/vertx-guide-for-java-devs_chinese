= 安全和控制访问

TIP: 	相应的源代码位于指南存储库的 `step-7` 文件夹中。

安全和控制访问对于Vert.x来说很容易。 在本节中，我们将：

1. 从HTTP转移到HTTPS，
2. 使用基于组的权限将用户身份验证添加到Web应用程序，
3. 使用 https://jwt.io/[_JSON web 令牌_ (JWT)]  对Web API进行控制访问。

== Vert.x的HTTPS支持

Vert.x提供对SSL加密网络连接的支持。通过一个前端HTTP服务器或者像Nginx一样的代理来发布在生产环境中的HTTP服务器，并且使用HTTPS传入连接是很常见的。Vert.x也可以自己发布HTTPS，以提供端到端的加密。

证书可以存储在Java _KeyStore_ 文件中。您可能需要用于测试目的的 _自签名证书_ ，以下是如何在密码为 `secret` 的 `server-keystore.jks` KeyStore中创建一个证书：

[source,text,indent=0]
----
include::gen-keystore.sh[tags=https-keygen]
----

然后，我们可以更改HTTP服务器创建，以传递 `HttpServerOptions` 对象来指定我们需要SSL，并指向我们的KeyStore文件：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=https-server]
----

我们可以将浏览器指向 https://localhost:8080/ ，但由于证书是自签名的，所以任何优秀的浏览器都会正确地产生安全警告：

image::images/invalid-cert.png[]

最后但并非最不重要的是，我们需要在 `ApiTest` 中更新测试用例，因为原始代码是用于通过Web客户端发出HTTP请求的：

[source,java,indent=0]
----
include::src/test/java/io/vertx/guides/wiki/http/ApiTest.java[tags=test-https]
----
<1> 确保SSL。
<2> 由于证书是自签名的，我们需要明确信任它，否则Web客户端就像Web浏览器一样连接将失败。

== 访问控制和认证

Vert.x为执行身份验证和授权提供了广泛的选项。官方支持的模块涵盖了JDBC，MongoDB， https://shiro.apache.org/[Apache Shiro] ，OAuth2以及众所周知的提供者和JWT（JSON Web令牌）。

虽然下一部分将介绍JWT，但本部分重点介绍如何使用Apache Shiro，这在验证必须由LDAP或Active Directory服务器支持时特别有用。在我们的例子中，我们只是将凭据存储在属性文件中以保持简单，但对LDAP服务器的API使用保持不变。

目标是要求用户使用wiki进行身份验证，并拥有基于角色的权限：

* 没有角色只允许阅读页面，
* 具有 _写_ 角色允许编辑页面，
* 具有 _编辑_ 角色允许创建，编辑和删除页面，
* 具有 _管理_ 角色相当于具有所有可能的角色。

WARNING: 由于Apache Shiro的内部运作，Vert.x Shiro集成有一些问题。有些部分阻塞会影响性能，有些数据是使用线程本地状态存储的。您不应该尝试滥用暴露的内部状态API。

=== 将Apache Shiro身份验证添加到路由

第一步是将 `vertx-auth-shiro` 模块添加到Maven依赖关系列表中：

[source,xml,indent=0]
----
include::pom.xml[tags=shiro]
----

我们使用的属性文件定义如下，位于 `src/main/resources/wiki-users.properties`:

[source,index=0]
----
include::src/main/resources/wiki-users.properties[tags=props]
----

以 `user` 为前缀的条目是用户帐户，其中第一个值条目是可能跟随角色的密码。 在这个例子中，用户 `bar` 有密码 `baz`，是一个 `编写` 角色 ，`编写` 角色有  `更新` 权限。

回到 `HttpServerVerticle` 类代码，我们使用Apache Shiro创建一个身份验证提供程序：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=shiro-auth]
----

`ShiroAuth` 对象实例用于处理服务器端用户会话：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=shiro-routes]
----
<1> 我们为所有路由安装用户会话处理器。
<2> 当请求没有用户会话时，这会自动将请求重定向到 `/login` 。
<3> 我们为需要认证的所有路由安装 `authHandler`。

最后，我们需要创建3条路由来显示登录表单，处理登录表单提交和注销用户：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=shiro-login]
----
<1> `FormLoginHandler` 是处理登录提交请求的帮助器。 默认情况下，它期望HTTP POST请求具有：作为登录名的 `username`，作为密码的 `password` 以及成功时作为重定向URL的 `return_url` 。
<2> 注销用户很简单，就像从当前的 `RoutingContext` 中清除它一样。

`loginHandler` 方法的代码是：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=loginHandler]
----

HTML模板放置在 `src/main/resources/templates/login.ftl`:

[source,html]
----
include::src/main/resources/templates/login.ftl[]
----

登录页面如下所示：

image::images/login-form.png[]

=== 支持基于角色的功能

只有当用户拥有足够的权限时才能激活功能。 在以下屏幕截图中，管理员可以创建一个页面并执行备份：

image::images/as-root.png[]

相比之下，没有角色的用户不能执行这些操作：

image::images/as-baz.png[]

To do that, we can access the `RoutingContext` user reference, and query for permissions.
Here is how this is implemented for the `indexHandler` handler method:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=indexHandler]
----
<1> This is how a permission query is made. Note that this is an asynchronous operation.
<2> We use the result to...
<3> ...leverage it in the HTML template.
<4> We also have access to the user login.

The template code has been modified to only render certain fragments based on the value of `canCreatePage`:

[source,html]
----
include::src/main/resources/templates/index.ftl[]
----

The code is similar for ensuring that updating or deleting a page is restricted to certain roles and is available from the guide Git repository.

It is important to ensure that checks are also being done on HTTP POST request handlers and not just when rendering HTML pages.
Indeed, malicious attackers could still craft requests and perform actions while not being authenticated.
Here is how to protect page deletions by wrapping the `pageDeletionHandler` code inside a topmost permission check:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=pageDeletionHandler]
----

== Authenticating web API requests with JWT

https://jwt.io/[JSON Web Tokens] (https://tools.ietf.org/html/rfc7519[RFC 7519]) is a standard for issuing JSON-encoded tokens containing _claims_, typically identifying a user and permissions, although claims can be just about anything.

A token is issued by a server and it is signed with the server key.
A client can send a token back along with subsequent requests: both the client and the server can check that a token is authentic and unaltered.

WARNING: While a JWT token is signed, its content is not encrypted. It must be transported over a secure channel (e.g., HTTPS) and it should never have sensitive data as a claim (e.g., passwords, private API keys, etc).

=== Adding JWT support

We start by adding the `vertx-auth-jwt` module to the Maven dependencies:

[source,xml,indent=0]
----
include::pom.xml[tags=jwt]
----

We will have a JCEKS keystore to hold the keys for our tests.
Here is how to generate a `keystore.jceks` with the suitable keys of various lengths:

[source,text,indent=0]
----
include::gen-keystore.sh[tags=jwt-keygen]
----

We need to install a JWT token handler on API routes:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=jwtAuth]
----

We pass `/api/token` as a parameter for the `JWTAuthHandler` object creation to specify that this URL shall be ignored.
Indeed, this URL is being used to generate new JWT tokens:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=issue-jwt]
----
<1> We expect login and password information to have been passed through HTTP request headers, and we authenticate using the Apache Shiro authentication provider of the previous section.
<2> Upon success we can query for roles.
<3> We generate a token with `username`, `canCreate`, `canDelete` and `canUpdate` claims.

Each API handler method can now query the current user principal and claims.
Here is how the `apiDeletePage` does it:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=apiDeletePage]
----

=== Using JWT tokens

To illustrate how to work with JWT tokens, let's create a new one for the `root` user:

----
$ http --verbose --verify no GET https://localhost:8080/api/token login:root password:w00t
GET /api/token HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:8080
User-Agent: HTTPie/0.9.8
login: root
password: w00t



HTTP/1.1 200 OK
Content-Length: 242
Content-Type: text/plain
Set-Cookie: vertx-web.session=8cbb38ac4ce96737bfe31cc0ceaae2b9; Path=/

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InJvb3QiLCJjYW5DcmVhdGUiOnRydWUsImNhbkRlbGV0ZSI6dHJ1ZSwiY2FuVXBkYXRlIjp0cnVlLCJpYXQiOjE0ODk0NDE1OTAsImlzcyI6IlZlcnQueCIsInN1YiI6Ildpa2kgQVBJIn0=.RmtJb81QKVUFreXL-ajZ8ktLGasoKEqG8GSQncRWrN8=
----

The response text is the token value and shall be retained.

We can check that performing an API request without the token results in a denial of access:

----
$ http --verbose --verify no GET https://localhost:8080/api/pages
GET /api/pages HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:8080
User-Agent: HTTPie/0.9.8



HTTP/1.1 401 Unauthorized
Content-Length: 12

Unauthorized
----

Sending a JWT token along with a request is done using a `Authorization` HTTP request header where the value must be `Bearer <token value>`.
Here is how to fix the API request above by passing the JWT token that had been issued to us:

----
$ http --verbose --verify no GET https://localhost:8080/api/pages 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InJvb3QiLCJjYW5DcmVhdGUiOnRydWUsImNhbkRlbGV0ZSI6dHJ1ZSwiY2FuVXBkYXRlIjp0cnVlLCJpYXQiOjE0ODk0NDE1OTAsImlzcyI6IlZlcnQueCIsInN1YiI6Ildpa2kgQVBJIn0=.RmtJb81QKVUFreXL-ajZ8ktLGasoKEqG8GSQncRWrN8='
GET /api/pages HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InJvb3QiLCJjYW5DcmVhdGUiOnRydWUsImNhbkRlbGV0ZSI6dHJ1ZSwiY2FuVXBkYXRlIjp0cnVlLCJpYXQiOjE0ODk0NDE1OTAsImlzcyI6IlZlcnQueCIsInN1YiI6Ildpa2kgQVBJIn0=.RmtJb81QKVUFreXL-ajZ8ktLGasoKEqG8GSQncRWrN8=
Connection: keep-alive
Host: localhost:8080
User-Agent: HTTPie/0.9.8



HTTP/1.1 200 OK
Content-Length: 99
Content-Type: application/json
Set-Cookie: vertx-web.session=0598697483371c7f3cb434fbe35f15e4; Path=/

{
    "pages": [
        {
            "id": 0,
            "name": "Hello"
        },
        {
            "id": 1,
            "name": "Apple"
        },
        {
            "id": 2,
            "name": "Vert.x"
        }
    ],
    "success": true
}
----

=== Adapting the API test fixture

The `ApiTest` class needs to be updated to support JWT tokens.

We add a new field for retrieving the token value to be used in test cases:

[source,java,indent=0]
----
include::src/test/java/io/vertx/guides/wiki/http/ApiTest.java[tags=tokenField]
----

We add first step to retrieve a JTW token authenticated as user `foo`:

[source,java,indent=0]
----
include::src/test/java/io/vertx/guides/wiki/http/ApiTest.java[tags=fetch-token]
----
<1> Credentials are passed as headers.
<2> The response payload is of `text/plain` type, so we use that for the body decoding codec.
<3> Upon success we complete the `tokenRequest` future with the token value.

Using the JWT token is now a matter of passing it back as a header to HTTP requests:

[source,java,indent=0]
----
include::src/test/java/io/vertx/guides/wiki/http/ApiTest.java[tags=use-token]
----
<1> We store the token with the `Bearer` prefix to the field for the next requests.
<2> We pass the token as a header.
