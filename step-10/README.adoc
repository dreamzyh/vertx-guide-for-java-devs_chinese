= 在事件总线上使用跨边界消息传递的实时web功能

TIP: 相应的源代码位于指南存储库的 `step-10` 文件夹中。

在本指南的较早部分，我们看到事件总线正在使用Vert.x应用程序中的消息传递进行通信。开发人员只需注册消费者即可接收消息并发送/发布消息。

SockJS事件总线桥将这些功能在Web浏览器中扩展到客户端。它创建了一个分布式事件总线，它不仅跨越集群中的多个Vert.x实例，还包括在(许多)浏览器中运行的客户端JavaScript。因此，我们可以创建包含许多浏览器和服务器的大型分布式事件总线，从而在分布式应用程序的所有组成部分中建立一致的基于消息的编程模型。

在本章中，我们将修改 `step-9` 中的代码，以便：

* 要呈现的Markdown内容将被发送到服务器，而不会创建新的HTTP请求
* 当用户编辑刚刚被其他用户修改的页面时, 该页显示一个警告。

== 设置SockJS事件总线桥

=== 在服务器上

[NOTE]
====
SockJS是一个客户端JavaScript库和协议，它提供了一个简单的类似WebSocket的接口，用于连接到SockJS服务器，而不管实际的浏览器或网络是否允许真正的WebSocket。它通过在浏览器和服务器之间支持各种不同的传输，并根据其功能在运行时选择一个来实现。
====

作为第一步，我们需要设置由 `vertx-web` 项目提供的 `SockJSHandler` ：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=sockjs-handler-setup]
----
<1> 为此 `vertx` 实例创建一个新的 `SockJSHandler` 。
<2> 允许从 `app.markdown` 地址传递来自浏览器的消息。在编辑wiki页面时，我们将使用此地址让服务器处理Markdown内容。
<3> 允许将消息发送到 `page.saved` 地址上的浏览器。我们将使用此地址通知浏览器Wiki页面已被修改。
<4> 配置处理器以将SockJS流量桥接到事件总线。Configure the handler to bridge SockJS traffic to the event bus.
<5> 使用SockJS处理器处理 `/eventbus` 路径下的所有请求。

[CAUTION]
====
对于大多数应用程序，您可能不希望客户端JavaScript能够将任何消息发送到服务器端的任何处理器或所有其他浏览器。例如：

* 您可能在事件总线上有一项服务，允许访问或删除数据，显然，我们不希望行为恶劣或恶意的客户端能够删除数据库中的所有数据，
* 我们不一定希望任何客户端能够听取任何事件总线地址。

为了解决这个问题，SockJS桥默认会拒绝任何消息。这就是为什么你要告诉桥什么样的信息可以通过(因为总是允许通过的例外回复信息)。
====

=== 在客户端上

现在服务器已准备好接受消息，我们将配置客户端。

首先，必须加载SockJS库和Vert.x事件总线JavaScript客户端。 最简单的入门方法是从公共内容传输网络获取文件：

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=load-sockjs-eventbus-scripts]
----

NOTE: 事件总线客户端可以预先下载并与应用程序捆绑在一起。 它发布在 `Maven`, `npm`, `bower`,甚至 `webjars` 仓库中。

然后，我们创建一个 `EventBus` Javascript对象的新实例：

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=event-bus-js-setup]
----

== 通过事件总线发送Markdown内容进行处理

SockJS桥现在正在运行。为了处理服务器端的Markdown内容，我们需要注册一个消费者。消费者处理发送到 `app.markdown` 地址的消息：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=eventbus-markdown-consumer]
----

这里没有什么新东西，我们之前已经创建了事件总线消费者。现在我们来看看客户端代码中发生了什么：

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=eventbus-markdown-sender]
----
<1> The _reply handler_ is a function taking two parameters: an error (if any) and the `reply` object.
The `reply` object content is nested inside the `body` property.
<2> Since the event bus client is not managed by AngularJS, `$scope.$apply` wraps the callback to perform proper scope life-cycle.
<3> As we did when working with `$http`, we invoke `updateRendering` with the HTML result.

Admittedly, the code is very similar to its HTTP endpoint equivalent.
However the benefit here does not lie in the number of lines of code.

Indeed, if you communicate with the server over the event bus, the bridge transparently distributes incoming messages among registered consumers.
Consequently, when Vert.x runs in cluster mode, the browser is not tied to a single server for processing (apart from the SockJS connection).
What's more the connection to the server is never closed, so with HTTP/1.1 this saves establishing a TCP connection for each request, which may be useful if you have lots of exchanges between servers and clients.

== Warning the user when the page is modified

In many applications, the _last commit wins_ principle is how conflicts are being resolved: when two users edit the same resource at the same time, the last one to press the _save_ button overwrites any previous changes.

There are ways around this issue, like entity versioning or extensive literature on the topic of distributed consensus.
Nevertheless, let's stick to a simple solution and see how we can notify the user when a change has been made so that at the very least (s)he can get a chance to deal with the situation.
As soon as the content has been changed in the database, the user can decide what is the best course of action to take: overwrite or reload.

To start with, we need to add an `alert alert-warning` message `div` in the page.
But we want it to show-up only when the `pageModified` scope variable is set to `true`.

[source,html,indent=0]
----
include::src/main/resources/webroot/index.html[tags=reload-warning]
----

Now, `pageModified` must be set to `true` when this page is saved.
Let's register an event bus handler for the `page.saved` address:

[source,javascript,indent=0]
----
include::src/main/resources/webroot/wiki.js[tags=register-page-saved-handler]
----
<1> We do not want to print the warning if we modified the content ourselves so we need a client identifier.
<2> The callback will be invoked when a message is received on the `page.saved` address.
<3> Check that the body is not empty.
<4> Make sure this event is related to the current wiki page.
<5> Check that we are not the origin of the changes.
<6> Since the event bus client is not managed by AngularJS, `$scope.$apply` wraps the callback to perform proper scope life cycle.
<7> Set `pageModified` to true.

Eventually we have to push messages when the content of a page is saved in the database:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/http/HttpServerVerticle.java[tags=publish-on-page-updated]
----
<1> `rxSavePage` returns a `Single<Void>` object.
On success (i.e. no database failure) we publish an event.
<2> The message contains the page identifier.
<3> The message contains the client identifier.
<4> The event is published on the `page.saved` address.

If we open the application in two tabs inside the same browser (or different browsers), select the same page on both, and update the content in one, the warning message is printed:

image::images/edited-warning.png[]

We could easily leverage the SockJS bridge for other purposes, like showing how many users are currently on a given page, supporting live comments in a chat box, etc.
The key point is that both the server and the client sides share the same programming model by message passing over the event-bus.
