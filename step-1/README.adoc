= 用Vert.x编写的最小可使用的wiki

TIP: 相应的源代码位于指南存储库的 `step-1` 文件夹中。

我们将从第一次迭代开始，最简单的代码可能是用Vert.x编写一个wiki。 虽然接下来的迭代将会在代码库中引入更多的功能以及正确的测试，但是我们将会看到，使用Vert.x进行快速原型设计既是一个简单而又实际的选择。

在这个阶段，wiki将使用HTML页面的服务器端呈现和通过JDBC进行数据持久性。 为此，我们将使用以下库。

1. http://vertx.io/docs/vertx-web/java/[Vert.x web]作为Vert.x核心库支持创建HTTP服务器，但不提供简洁的API来处理路由，处理请求的有效载荷等。
2. http://vertx.io/docs/vertx-jdbc-client/java/[Vert.x JDBC 客户端]通过JDBC提供异步API。
3. http://freemarker.org/[Apache FreeMarker]渲染服务器端页面，因为它是一个简单的模板引擎。
4. https://github.com/rjeschke/txtmark[Txtmark]将Markdown文本呈现为HTML，允许在Markdown中编辑wiki页面。

== 引导一个Maven项目

本指南选择使用 https://maven.apache.org[Apache Maven]作为构建工具，主要是因为它与主要的集成开发环境很好地结合在一起。 您可以同样使用另一个构建工具，如 https://gradle.org/[Gradle]。

Vert.x社区提供了可以克隆的来自https://github.com/vert-x3/vertx-maven-starter的模板项目结构。 由于您也可能想要使用（Git）版本控制，最快的方法是克隆存储库，删除其 `.git/` 文件夹，然后创建一个新的Git存储库：

    git clone https://github.com/vert-x3/vertx-maven-starter.git vertx-wiki
    cd vertx-wiki
    rm -rf .git
    git init

该项目提供了一个简单的verticle以及单元测试。 您可以安全地删除 `src/` 下的所有 `.java` 文件来破解wiki，但在这之前，您可以测试项目是否成功建立并运行：

    mvn package exec:java

你会注意到Maven项目的 `pom.xml` 有两个有趣的事情：

1. 它使用 https://maven.apache.org/plugins/maven-shade-plugin/[Maven Shade Plugin]创建一个具有所有必需依赖项的单个Jar归档文件，后缀为 `-fat.jar`，也称为“fat Jar”
2. 它使用 http://www.mojohaus.org/exec-maven-plugin/[Exec Maven Plugin] 来提供 `exec:java` 目标，依次通过Vert.x的 `io.vertx.core.Launcher`类启动应用程序。 这实际上相当于使用Vert.x发行版中的 `vertx`命令行工具来运行。

最后，您会注意到 `redeploy.sh` 和 `redeploy.bat` 脚本的存在，您可以使用它们在代码更改时自动编译和重新部署。 请注意，这样做需要确保这些脚本中的 `VERTICLE` 变量与要使用的主Verticle相匹配。

[NOTE]
====
或者，Fabric8项目托管一个 https://vmp.fabric8.io/[a Vert.x Maven plugin]。 它的目标是初始化，构建，打包和运行Vert.x项目。

通过克隆Git启动器存储库来生成一个类似的项目：

    mkdir vertx-wiki
    cd vertx-wiki
    mvn io.fabric8:vertx-maven-plugin:1.0.7:setup -DvertxVersion=3.5.0
    git init

====

== 添加所需的依赖关系

要添加到Maven `pom.xml` 文件的第一批依赖关系是用于Web处理和呈现的：

[source,xml,indent=0]
----
include::pom.xml[tags=web-deps]
----

TIP: 正如 `vertx-web-templ-freemarker` 的名字所暗示的，Vert.x web为流行的模板引擎提供可插入的支持：Handlebars，Jade，MVEL，Pebble，Thymeleaf，当然还有Freemarker。

依赖关系的第二次设置是那些JDBC数据库访问所需的：

[source,xml,indent=0]
----
include::pom.xml[tags=db-deps]
----

Vert.x JDBC客户端库提供对任何JDBC兼容数据库的访问，但是当然我们的项目需要在 _classpath_ 上有一个JDBC驱动程序。

http://hsqldb.org/[HSQLDB] 是用Java编写的著名关系数据库。 用作嵌入式数据库，以避免需要单独运行第三方数据库服务器时非常流行。 它在单元和集成测试中也很受欢迎，因为它提供了一个（易失性）内存存储。

HSQLDB作为嵌入式数据库非常适合我们开始。 它将数据存储在本地文件中，而且由于HSQLDB库Jar提供了一个JDBC驱动程序，所以Vert.x JDBC配置将很简单。

[NOTE]
====
Vert.x还提供专用的 http://vertx.io/docs/vertx-mysql-postgresql-client/java/[MySQL和PostgreSQL客户端库]。

当然，您可以使用通用Vert.x JDBC客户端连接到MySQL或PostgreSQL数据库，但这些库通过使用这两种数据库服务器网络协议而不是通过（阻塞）JDBC API来提供更好的性能。
====

NOTE: Vert.x还提供库来处理流行的非关系数据库 http://vertx.io/docs/vertx-mongo-client/java/[MongoDB]和 http://vertx.io/docs/vertx-redis-client/java/[Redis]。 较大的社区提供与Apache Cassandra，OrientDB或ElasticSearch等其他存储系统的集成。

== verticle的解析

我们的wiki的verticle由一个 `io.vertx.guides.wiki.MainVerticle` 的Java类组成。 这个类扩展了 `io.vertx.core.AbstractVerticle`，主要提供了Verticle的基类主要提供了如下：

1. 生命周期 `start` 和  `stop` 方法来覆盖
2. 一个名为vertx的 _protected_ 字段，引用Verticle正在部署的Vert.x环境
3. 一个配置对象的访问器，允许将外部配置传递给Verticle。

要开始我们的verticle可以覆盖 `start` 方法，如下所示:

[source,java]
----
public class MainVerticle extends AbstractVerticle {

  @Override
  public void start(Future<Void> startFuture) throws Exception {
    startFuture.complete();
  }
}
----

有 `start` 和 `stop` 两种形式的方法：一个没有参数，一个有 _future_ 对象引用。 无参数变量意味着verticle初始化或内务阶段总是成功，除非抛出异常。 具有  _future_  对象的变量提供了更细粒度的方法，以最终表示操作成功与否。 事实上，一些初始化或I/O操作可能需要异步操作，所以含有 _future_ 对象的写法自然适合异步的习惯用法。

== 关于Vert.x的future对象和回调的介绍

Vert.x的future不是JDK的future：它们可以以非阻塞的方式进行组合和查询。 它们应该用于简单协调异步任务，特别是部署Verticle并检查是否成功部署。

Vert.x核心API基于回调来通知异步事件。 经验丰富的开发人员自然会认为，这为所谓的“回调地狱”打开了大门，其中多层次的嵌套回调使得代码难以理解，如这个虚构的代码所示：

[source,java]
----
foo.a(1, res1 -> {
  if (res1.succeeded()) {
    bar.b("abc", 1, res2 -> {
      if (res.succeeded()) {
         baz.c(res3 -> {
           dosomething(res1, res2, res3, res4 -> {
               // (...)
           });
         });
      }
    });
  }
});
----

虽然核心API可以被设计为有利于约定和future，回调的选择实际上是有趣的，因为它允许使用不同的编程抽象。 Vert.x是一个很大程度上没有意见的项目，回调允许实现更好地应对异步编程的不同模型：被动扩展（通过RxJava），约定和future，fibers（使用字节码工具）等。

由于所有的Vert.x API都是在面向回调的，所以在像RxJava这样的其他抽象可以被利用之前，本指南只使用第一部分中的回调来确保读者熟悉Vert.x中的核心概念。从回调开始，在异步代码的许多部分之间画一条线也可以说比较容易。一旦在示例代码中发现回调并不总是容易读懂的代码，我们将引入RxJava支持来展示如何通过思考已处理事件流来更好地表达相同的异步代码。

== Wiki的verticle初始化阶段

为了让我们的wiki运行，我们需要执行两阶段初始化：To get our wiki running, we need to perform a 2-phases initialization:

1. 我们需要建立一个JDBC数据库连接，并确保数据库模式(database schema)已经到位
2. 我们需要为Web应用程序启动一个HTTP服务器。

每个阶段都可能失败（例如，HTTP服务器的TCP端口已被使用），并且它们不应该并行运行，因为Web应用程序代码首先需要数据库访问才能工作。Each phase can fail (e.g., the HTTP server TCP port is already being used), and they should not run in parallel as the web application code first needs the database access to work.

为了使代码更 _清晰_，我们将在每个阶段定义1个方法，并采用返回 _future/promise_ 对象的模式来通知每个阶段何时完成，以及是否成功完成：

[source,java]
----
private Future<Void> prepareDatabase() {
  Future<Void> future = Future.future();
  // (...)
  return future;
}

private Future<Void> startHttpServer() {
  Future<Void> future = Future.future();
  // (...)
  return future;
}
----

通过让每个方法返回一个 _future_ 对象，`start` 方法的实现变成一个组合：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=start]
----

当 `prepareDatabase` 的 _future_ 成功完成时， `startHttpServer` 被调用，并且 `steps` future 将根据 `startHttpServer` 的future 返回结果来完成。 如果 `prepareDatabase` 遇到错误，则 `startHttpServer` 将永远不会被调用，在这种情况下，`steps` _future_  将处于  _failed_ 状态，并且会以描述错误的异常来完成。

最终 `steps` 完成：`setHandler` 定义一个处理程序，在完成时调用。 在我们的例子中，我们只是想通过 `steps` 完成 `startFuture`，并使用 `completer` 方法来获得一个处理程序。 这相当于：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=another-start]
----
<1> `ar` 的类型是 `AsyncResult<Void>`。`AsyncResult<T>` 用于传递异步处理的结果，可能会在成功时产生的 `T` 类型的值，或者失败异常是处理失败。

=== 数据库初始化

wiki数据库模式由一个表单 `Pages` 组成，其中包含以下列：

[options="header"]
|===
|列 |类型 |描述

|`Id`
|Integer
|主键(Primary key)

|`Name`
|Characters
|wiki页面的名字，必须是唯一的

|`Content`
|Text
|wiki页面的Markdown文本
|===

数据库操作将是典型的 _创建，读取，更新，删除_ 操作。 为了让我们开始，我们简单地将相应的SQL查询存储为  `MainVerticle` 类的静态字段。 请注意，它们是用HSQLDB可理解的SQL方言编写的，但其他关系数据库可能不一定支持：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=sql-fields]
----
<1> 这个 `?` 在查询中是占位符，在执行查询时传递数据，Vert.x JDBC客户端阻止SQL注入。

应用程序Verticle需要保留对作为数据库连接的 `JDBCClient` 对象（来自 `io.vertx.ext.jdbc` 包）的引用。 我们在 `MainVerticle` 中使用了一个字段，我们还从 `org.slf4j` 包创建了一个通用记录器：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=db-and-logger]
----

最后但并非最不重要的，这里是 `prepareDatabase`  方法的完整实现。 它尝试获取JDBC客户端连接，然后执行SQL查询以创建 `Pages` 表，除非它已经存在：

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=prepareDatabase]
----
<1> `createShared` 创建一个共享的连接，在 `vertx` 实例的已知verticle中共享，这通常是件好事。
<2> JDBC客户端连接是通过传递一个Vert.x JSON对象来完成的。这里的 `url` 是JDBC的URL。
<3> 就像  `url` 一样， `driver_class` 是特定于正在使用的JDBC驱动程序，并指向驱动程序类。
<4> `max_pool_size` 是并发连接的数量。我们在这里选择了30个，但它只是一个任意数字。
<5> 获取连接是一个异步操作，它为我们提供了一个 `AsyncResult<SQLConnection>` 。然后必须测试它是否可以建立连接（`AsyncResult`实际上是`Future`的父接口）。
<6> 如果无法获得SQL连接，那么方法 _future_ 将通过 `cause` 方法以 `AsyncResult` 提供的异常完成失败处理。
<7> `SQLConnection` 是成功的 `AsyncResult` 的结果。我们可以用它来执行一个SQL查询。
<8> 在检查SQL查询是否成功之前，我们必须通过调用 `close` 来释放它，否则JDBC客户端连接池最终可能会耗尽。
<9> 我们成功地完成方法 _future_ 对象。

TIP: The SQL database modules supported by the Vert.x project do not currently offer anything beyond passing SQL queries (e.g., an object-relationnal mapper) as they focus on providing asynchronous access to databases.
However, nothing forbids using https://github.com/vert-x3/vertx-awesome[more advanced modules from the community], and we especially recommend checking out projects like https://github.com/jklingsporn/vertx-jooq[this jOOq generator for Vert.x] or https://github.com/BraintagsGmbH/vertx-pojo-mapper[this POJO mapper].

=== Notes about logging

The previous subsection introduced a logger, and we opted for the https://www.slf4j.org/[SFL4J library].
Vert.x is also unopinionated on logging: you can choose any popular Java logging library.
We recommend SLF4J since it is a popular logging abstraction and unification library in the Java ecosystem.

We also recommend using https://logback.qos.ch/[Logback] as a logger implementation.
Integrating both SLF4J and Logback can be done by adding two dependencies, or just `logback-classic` that points to both libraries (incidentally they are from the same author):

[source,xml,indent=0]
----
include::pom.xml[tags=logger]
----

By default SLF4J outputs many log events to the console from Vert.x, Netty, C3PO and the wiki application.
We can reduce the verbosity by adding the a `src/main/resources/logback.xml` configuration file (see https://logback.qos.ch/ for more details):

[source,xml,indent=0]
----
include::src/main/resources/logback.xml[tags=conf]
----

Last but not least HSQLDB does not integrate well with loggers when embedded.
By default it tries to reconfigure the logging system in place, so we need to disable it by passing a `-Dhsqldb.reconfig_logging=false` property to the Java Virtual Machine when executing applications.

=== HTTP server initialization

The HTTP server makes use of the `vertx-web` project to easily define _dispatching routes_ for incoming HTTP requests.
Indeed, the Vert.x core API allows to start HTTP servers and listen for incoming connections, but it does not provide any facility to, say, have different handlers depending on the requested URL or processing request bodies.
This is the role of a _router_ as it dispatches requests to different processing handlers depending on the URL, the HTTP method, etc.

The initialization consists in setting up a _request router_, then starting the HTTP server:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=startHttpServer]
----
<1> The `vertx` context object provides methods to create HTTP servers, clients, TCP/UDP servers and clients, etc.
<2> The `Router` class comes from `vertx-web`: `io.vertx.ext.web.Router`.
<3> Routes have their own handlers, and they can be defined by URL and/or by HTTP method. For short handlers a Java lambda is an option, but for more elaborated handlers it is a good idea to reference private methods instead. Note that URLs can be parametric: `/wiki/:page` will match a request like `/wiki/Hello`, in which case a `page` parameter will be available with value `Hello`.
<4> This makes all HTTP POST requests got through a first handler, here `io.vertx.ext.web.handler.BodyHandler`. This handler automatically decodes the body from the HTTP requests (e.g., form submissions), which can then be manipulated as Vert.x buffer objects.
<5> The router object can be used as a HTTP server handler, which then dispatches to other handlers as defined above.
<6> Starting a HTTP server is an asynchronous operation, so an `AsyncResult<HttpServer>` needs to be checked for success. By the way the `8080` parameter specifies the TCP port to be used by the server.

== HTTP router handlers

The HTTP router instance of the `startHttpServer` method points to different handlers based on URL patterns and HTTP methods.
Each handlers deals with a HTTP request, performs a database query, and renders HTML from a FreeMarker template.

=== Index page handler

The index page provides a list of pointers to all wiki entries and a field to create a new one:

image::images/index.png[Wiki index]

The implementation is a straightforward `select *` SQL query where data is then passed to the FreeMarker engine to render the HTML response.

The `indexHandler` method code is as follows:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=indexHandler]
----
<1> SQL query results are being returned as instances of `JsonArray` and `JsonObject`.
<2> The `RoutingContext` instance can be used to put arbitrary key / value data that is then available from templates, or chained router handlers.
<3> Rendering a template is an asynchronous operation that leads us to the usual `AsyncResult` handling pattern.
<4> The `AsyncResult` contains the template rendering as a `String` in case of success, and we can end the HTTP response stream with the value.
<5> In case of failure the `fail` method from `RoutingContext` provides a sensible way to return a HTTP 500 error to the HTTP client.

FreeMarker templates shall be placed in the `src/main/resources/templates` folder.
The `index.ftl` template code is as follows:

[source,html]
----
include::src/main/resources/templates/index.ftl[]
----

Key / value data stored in the `RoutingContext` object is made available through the `context` FreeMarker variable.

Since lots of templates have common header and footers, we extracted the following code in `header.ftl` and `footer.ftl`:

.`header.ftl`
[source,html]
----
include::src/main/resources/templates/header.ftl[]
----

.`footer.ftl`
[source,html]
----
include::src/main/resources/templates/footer.ftl[]
----

=== Wiki page rendering handler

This handler deals with HTTP GET requests to have wiki pages being rendered, as in:

image::images/page.png[Wiki page]

The page also provides a button to edit the content in Markdown.
Instead of having a separate handler and template, we simply rely on JavaScript and CSS to toggle the editor on and off when the button is being clicked:

image::images/edit.png[Wiki editor]

The `pageRenderingHandler` method code is the following:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=pageRenderingHandler]
----
<1> URL parameters (`/wiki/:name` here) can be accessed through the context request object.
<2> Passing argument values to SQL queries is done using a `JsonArray`, with the elements in order of the `?` symbols in the SQL query.
<3> The `Processor` class comes from the _txtmark_ Markdown rendering library that we use.

The `page.ftl` FreeMarker template code is as follows:

[source,html]
----
include::src/main/resources/templates/page.ftl[]
----

=== Page creation handler

The index page offers a field to create a new page, and its surrounding HTML form points to a URL that is being managed by this handler.
The strategy isn't actually to create a new entry in the database, but simply to redirect to a wiki page URL with the name to create.
Since the wiki page doesn't exist, the `pageRenderingHandler` method will use a default text for new pages, and a user can eventually create that page by editing then saving it.

The handler is the `pageCreateHandler` method, and its implementation is a redirection through a HTTP 303 status code:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=pageCreateHandler]
----

=== Page saving handler

The `pageUpdateHandler` method deals with HTTP POST requests when saving a wiki page.
This happens both when updating an existing page (issuing a SQL `update` query) or saving a new page (issuing a SQL `insert` query):

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=pageUpdateHandler]
----
<1> Form parameters sent through a HTTP POST request are available from the `RoutingContext` object. Note that without a `BodyHandler` within the `Router` configuration chain these values would not be available, and the form submission payload would need to be manually decoded from the HTTP POST request payload.
<2> We rely on a form hidden field rendered in the `page.ftl` FreeMarker template to know if we are updating an existing page or saving a new page.
<3> Again, preparing the SQL query with parameters uses a `JsonArray` to pass values.
<4> The `updateWithParams` method is used for `insert` / `update` / `delete` SQL queries.
<5> Upon success, we simply redirect to the page that has been edited.

=== Page deletion handler

The implementation of the `pageDeletionHandler` method is straightforward: given a wiki entry identifier, it issues a `delete` SQL query then redirects to the wiki index page:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=pageDeletionHandler]
----

== Running the application

At this stage we have a working, self-contained wiki application.

To run it we first need to build it with Maven:

    $ mvn clean package

Since the build produces a Jar will all required dependencies embedded (including Vert.x and a JDBC database), running the wiki is as simple as:

    $ java -jar target/wiki-step-1-1.1.0-fat.jar

You can then point your favorite web browser to http://localhost:8080/ and enjoy using the wiki.
